---
title: "matrices"
output: html_document
date: "2026-01-11"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r}
library(data.table)

```

## Including Plots

You can also embed plots, for example:

```{r}

#formica transects
matrices <- as.data.table(list.files("Z:/shares/forse/2_tls/matrices/formica_transects/", recursive = T, pattern = "*.DAT", full.names = T))

# split path
parts <- tstrsplit(matrices$V1, "/", fixed = TRUE)

# convert to data.table
dt_parts <- as.data.table(parts)

# keep last 4 columns
matrices <- dt_parts[, (ncol(dt_parts)-2):ncol(dt_parts), with = FALSE]


colnames(matrices) <- c("region1", "region2", "matrix")

matrices[, scanposition:=tools::file_path_sans_ext(matrix)]

setkeyv(matrices, c("region1", "region2", "scanposition"))

old_metrics_formica_transects <- old_metrics[region1=="formica_transects", 
                                             c("region1", "region2", "scanposition", "file")]
setkeyv(old_metrics_formica_transects, c("region1", "region2", "scanposition")) 

combined_formica_transects <- old_metrics_formica_transects[matrices, nomatch = 0]

combined_formica_transects[, oldname:=file.path("Z:/shares/forse/2_tls/matrices", region1, region2, matrix)]
combined_formica_transects[, newname:=file.path("Z:/shares/forse/2_tls/matrices", region1, "_final_used", region2, paste0(file, ".DAT"))]

# Create dirs only for valid newname values
combined_formica_transects[
  !is.na(newname) & nzchar(newname),
  dir.create(dirname(newname), recursive = TRUE, showWarnings = FALSE),
  by = .I
]

combined_formica_transects[, ok := FALSE]

combined_formica_transects[
  file.exists(oldname),
  ok := file.copy(oldname, newname, overwrite = TRUE),
  by = .I
]
```

```{r}
#berchtesgaden
matrices <- as.data.table(list.files("Z:/shares/forse/2_tls/matrices/berchtesgaden/", recursive = T, pattern = "*.DAT", full.names = T))

matrices <- matrices[!grepl("_final_used", V1)]

# split path
parts <- tstrsplit(matrices$V1, "/", fixed = TRUE)

# convert to data.table
dt_parts <- as.data.table(parts)

# keep last 4 columns
matrices.bgd <- dt_parts[, (ncol(dt_parts)-2):ncol(dt_parts), with = FALSE]


colnames(matrices.bgd) <- c("region1", "project2", "matrix")

matrices.bgd[, scanposition:=tools::file_path_sans_ext(matrix)]

setkeyv(matrices.bgd, c("region1", "project2", "scanposition"))

old_metrics_bgd <- old_metrics[region1=="berchtesgaden", 
                                             c("region1", "project2", "scanposition", "file")]
old_metrics_bgd[,project2:=sub("BER","BGD",project2)]
setkeyv(old_metrics_bgd, c("region1", "project2", "scanposition")) 


combined_bgd <- old_metrics_bgd[matrices.bgd, nomatch = 0]


combined_bgd[, oldname:=file.path("Z:/shares/forse/2_tls/matrices", region1, project2, matrix)]
combined_bgd[, newname:=file.path("Z:/shares/forse/2_tls/matrices", region1, "_final_used", project2, paste0(file, ".DAT"))]

# Create dirs only for valid newname values
combined_bgd[
  !is.na(newname) & nzchar(newname),
  dir.create(dirname(newname), recursive = TRUE, showWarnings = FALSE),
  by = .I
]

combined_bgd[, ok := FALSE]

combined_bgd[
  file.exists(oldname),
  ok := file.copy(oldname, newname, overwrite = TRUE),
  by = .I
]
```

```{r}
#bosland
matrices <- as.data.table(list.files("Z:/shares/forse/2_tls/matrices/bosland/", recursive = T, pattern = "*.DAT", full.names = T))

matrices <- matrices[!grepl("_final_used", V1)]

# split path
parts <- tstrsplit(matrices$V1, "/", fixed = TRUE)

# convert to data.table
dt_parts <- as.data.table(parts)

# keep last 4 columns
matrices.bos <- dt_parts[, (ncol(dt_parts)-2):ncol(dt_parts), with = FALSE]


colnames(matrices.bos) <- c("region1", "project2", "matrix")

matrices.bos[, scanposition:=tools::file_path_sans_ext(matrix)]

setkeyv(matrices.bos, c("region1", "project2", "scanposition"))

old_metrics_bos <- old_metrics[region1=="bosland", 
                                             c("region1", "project2", "scanposition", "file")]
setkeyv(old_metrics_bos, c("region1", "project2", "scanposition")) 


combined_bos <- old_metrics_bos[matrices.bos, nomatch = 0]


combined_bos[, oldname:=file.path("Z:/shares/forse/2_tls/matrices", region1, project2, matrix)]
combined_bos[, newname:=file.path("Z:/shares/forse/2_tls/matrices", region1, "_final_used", project2, paste0(file, ".DAT"))]

# Create dirs only for valid newname values
combined_bos[
  !is.na(newname) & nzchar(newname),
  dir.create(dirname(newname), recursive = TRUE, showWarnings = FALSE),
  by = .I
]

combined_bos[, ok := FALSE]

combined_bos[
  file.exists(oldname),
  ok := file.copy(oldname, newname, overwrite = TRUE),
  by = .I
]

```

```{r}
#ash
matrices <- as.data.table(list.files("Z:/shares/forse/2_tls/matrices/ash/", recursive = T, pattern = "*.DAT", full.names = T))

matrices <- matrices[!grepl("_final_used", V1)]

# split path
parts <- tstrsplit(matrices$V1, "/", fixed = TRUE)

# convert to data.table
dt_parts <- as.data.table(parts)

# keep last 4 columns
matrices.ash <- dt_parts[, (ncol(dt_parts)-2):ncol(dt_parts), with = FALSE]


colnames(matrices.ash) <- c("region1", "region2", "matrix")

matrices.ash[, scanposition:=tools::file_path_sans_ext(matrix)]

setkeyv(matrices.ash, c("region1", "region2", "scanposition"))

old_metrics_ash <- old_metrics[region1=="ash", 
                                             c("region1", "region2", "scanposition", "file")]
setkeyv(old_metrics_ash, c("region1", "region2", "file")) 


combined_ash <- old_metrics_ash[matrices.ash, nomatch = 0]


combined_ash[, oldname:=file.path("Z:/shares/forse/2_tls/matrices", region1, region2, matrix)]
combined_ash[, newname:=file.path("Z:/shares/forse/2_tls/matrices", region1, "_final_used", region2, paste0(file, ".DAT"))]

# Create dirs only for valid newname values
combined_ash[
  !is.na(newname) & nzchar(newname),
  dir.create(dirname(newname), recursive = TRUE, showWarnings = FALSE),
  by = .I
]

combined_ash[, ok := FALSE]

combined_ash[
  file.exists(oldname),
  ok := file.copy(oldname, newname, overwrite = TRUE),
  by = .I
]

```

```{r}
#formica cities
matrices <- as.data.table(list.files("Z:/shares/forse/2_tls/matrices/formica_cities/", recursive = T, pattern = "*.DAT", full.names = T))

matrices <- matrices[!grepl("_final_used", V1)]

# split path
parts <- tstrsplit(matrices$V1, "/", fixed = TRUE)

# convert to data.table
dt_parts <- as.data.table(parts)

# keep last 4 columns
matrices.formica_cities <- dt_parts[, (ncol(dt_parts)-2):ncol(dt_parts), with = FALSE]


colnames(matrices.formica_cities) <- c("region1", "project", "matrix")

matrices.formica_cities[, scanposition:=tools::file_path_sans_ext(matrix)]

matrices.formica_cities[,project:=sub(".riproject", "",project)]
setkeyv(matrices.formica_cities, c("region1", "project", "scanposition"))


old_metrics_formica_cities <- old_metrics[region1=="formica_cities", 
                                             c("region1", "project", "scanposition", "file")]
old_metrics_formica_cities[,project:=sub(".RiSCAN", "",project)]
setkeyv(old_metrics_formica_cities, c("region1", "project", "scanposition")) 


combined_formica_cities <- old_metrics_formica_cities[matrices.formica_cities, nomatch = 0]


combined_formica_cities[, oldname:=file.path("Z:/shares/forse/2_tls/matrices", region1, project, matrix)]
combined_formica_cities[, newname:=file.path("Z:/shares/forse/2_tls/matrices", region1, "_final_used", project, paste0(file, ".DAT"))]

# Create dirs only for valid newname values
combined_formica_cities[
  !is.na(newname) & nzchar(newname),
  dir.create(dirname(newname), recursive = TRUE, showWarnings = FALSE),
  by = .I
]

combined_formica_cities[, ok := FALSE]

combined_formica_cities[
  file.exists(oldname),
  ok := file.copy(oldname, newname, overwrite = TRUE),
  by = .I
]

```

```{r}
#landshut
matrices <- as.data.table(list.files("Z:/shares/forse/2_tls/matrices/landshut/", recursive = T, pattern = "*.DAT", full.names = T))

matrices <- matrices[!grepl("_final_used", V1)]

# split path
parts <- tstrsplit(matrices$V1, "/", fixed = TRUE)

# convert to data.table
dt_parts <- as.data.table(parts)

# keep last 4 columns
matrices.formica_cities <- dt_parts[, (ncol(dt_parts)-2):ncol(dt_parts), with = FALSE]


colnames(matrices.formica_cities) <- c("region1", "project", "matrix")

matrices.formica_cities[, scanposition:=tools::file_path_sans_ext(matrix)]

matrices.formica_cities[,project:=sub(".riproject", "",project)]
setkeyv(matrices.formica_cities, c("region1", "project", "scanposition"))


old_metrics_formica_cities <- old_metrics[region1=="formica_cities", 
                                             c("region1", "project", "scanposition", "file")]
old_metrics_formica_cities[,project:=sub(".RiSCAN", "",project)]
setkeyv(old_metrics_formica_cities, c("region1", "project", "scanposition")) 


combined_formica_cities <- old_metrics_formica_cities[matrices.formica_cities, nomatch = 0]


combined_formica_cities[, oldname:=file.path("Z:/shares/forse/2_tls/matrices", region1, project, matrix)]
combined_formica_cities[, newname:=file.path("Z:/shares/forse/2_tls/matrices", region1, "_final_used", project, paste0(file, ".DAT"))]

# Create dirs only for valid newname values
combined_formica_cities[
  !is.na(newname) & nzchar(newname),
  dir.create(dirname(newname), recursive = TRUE, showWarnings = FALSE),
  by = .I
]

combined_formica_cities[, ok := FALSE]

combined_formica_cities[
  file.exists(oldname),
  ok := file.copy(oldname, newname, overwrite = TRUE),
  by = .I
]

```

```{r}
#gontrode
matrices <- as.data.table(list.files("Z:/shares/forse/2_tls/matrices/gontrode/", recursive = T, pattern = "*.DAT", full.names = T))

matrices <- matrices[!grepl("_final_used", V1)]

# split path
parts <- tstrsplit(matrices$V1, "/", fixed = TRUE)

# convert to data.table
dt_parts <- as.data.table(parts)

# keep last 4 columns
matrices.gontrode <- dt_parts[, (ncol(dt_parts)-2):ncol(dt_parts), with = FALSE]


colnames(matrices.gontrode) <- c("region1", "region2", "matrix")

matrices.gontrode[, scanposition:=tools::file_path_sans_ext(matrix)]

matrices.gontrode[,project:=sub(".riproject", "",project)]
setkeyv(matrices.gontrode, c("region1", "region2", "scanposition"))


old_metrics_gontrode <- old_metrics[region1=="gontrode", 
                                             c("region1", "region2", "scanposition", "file")]
setkeyv(old_metrics_gontrode, c("region1", "region2", "scanposition")) 


combined_gontrode <- old_metrics_gontrode[matrices.gontrode, nomatch = 0]


combined_gontrode[, oldname:=file.path("Z:/shares/forse/2_tls/matrices", region1, region2, matrix)]
combined_gontrode[, newname:=file.path("Z:/shares/forse/2_tls/matrices", region1, "_final_used", region2, paste0(file, ".DAT"))]

# Create dirs only for valid newname values
combined_gontrode[
  !is.na(newname) & nzchar(newname),
  dir.create(dirname(newname), recursive = TRUE, showWarnings = FALSE),
  by = .I
]

combined_gontrode[, ok := FALSE]

combined_gontrode[
  file.exists(oldname),
  ok := file.copy(oldname, newname, overwrite = TRUE),
  by = .I
]

```

```{r}

#morpho
matrices <- as.data.table(list.files("Z:/shares/forse/2_tls/matrices/morpho/", recursive = T, pattern = "*.DAT", full.names = T))

matrices <- matrices[!grepl("_final_used", V1)]

# split path
parts <- tstrsplit(matrices$V1, "/", fixed = TRUE)

# convert to data.table
dt_parts <- as.data.table(parts)

# keep last 4 columns
matrices.morpho <- dt_parts[, (ncol(dt_parts)-2):ncol(dt_parts), with = FALSE]


colnames(matrices.morpho) <- c("region1", "region2", "matrix")

matrices.morpho[, scanposition:=tools::file_path_sans_ext(matrix)]

setkeyv(matrices.morpho, c("region1", "region2", "scanposition"))


old_metrics_morpho <- old_metrics[region1=="morpho", 
                                             c("region1", "region2", "scanposition", "file")]
setkeyv(old_metrics_morpho, c("region1", "region2", "scanposition")) 


combined_morpho <- old_metrics_morpho[matrices.morpho, nomatch = 0]


combined_morpho[, oldname:=file.path("Z:/shares/forse/2_tls/matrices", region1, region2, matrix)]
combined_morpho[, newname:=file.path("Z:/shares/forse/2_tls/matrices", region1, "_final_used", region2, paste0(file, ".DAT"))]

# Create dirs only for valid newname values
combined_morpho[
  !is.na(newname) & nzchar(newname),
  dir.create(dirname(newname), recursive = TRUE, showWarnings = FALSE),
  by = .I
]

combined_morpho[, ok := FALSE]

combined_morpho[
  file.exists(oldname),
  ok := file.copy(oldname, newname, overwrite = TRUE),
  by = .I
]


```

```{r}
matrices <- as.data.table(list.files("Z:/shares/forse/2_tls/matrices/", recursive = T, pattern = "*.DAT", full.names = T))
matrices <- unlist(matrices[grepl("_final_used", V1)])


read_mat4 <- function(path) {
  # read all numeric tokens (robust to whitespace)
  x <- scan(path, what = numeric(), quiet = TRUE)
  if (length(x) < 16) stop("Not enough numeric values in: ", path)
  # take first 16 values, fill 4x4 row-wise
  matrix(x[1:16], nrow = 4, byrow = TRUE)
}

check_vertical <- function(M) {
  R <- M[1:3, 1:3]

  # scanner Z-axis expressed in world coordinates (3rd column)
  u <- R[, 3]

  # normalise just in case of tiny numeric drift
  u <- u / sqrt(sum(u^2))

  # tilt angle from world vertical [0,0,1]
  uz <- max(min(u[3], 1), -1)
  tilt_deg <- acos(uz) * 180 / pi

  # optional: roll/pitch (ZYX convention), useful diagnostics
  pitch <- asin(max(min(-R[3,1], 1), -1))
  roll  <- atan2(R[3,2], R[3,3])
  yaw   <- atan2(R[2,1], R[1,1])

  list(
    tilt_deg = tilt_deg,
    roll_deg = roll  * 180 / pi,
    pitch_deg = pitch * 180 / pi,
    yaw_deg = yaw   * 180 / pi
  )
}

res <- rbindlist(lapply(matrices, function(f) {
  M <- read_mat4(f)
  v <- check_vertical(M)
  data.table(
    file = f,
    tilt_deg = v$tilt_deg,
    roll_deg = v$roll_deg,
    pitch_deg = v$pitch_deg,
    yaw_deg = v$yaw_deg
  )
}), fill = TRUE)

# choose a threshold for "vertical"
# e.g. within 3 degrees of vertical:
res[, is_vertical := tilt_deg <= 3]

res[order(tilt_deg)]



```

